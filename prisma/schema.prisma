import express from "express";
import { PrismaClient } from "@prisma/client";
import { authMiddleware } from "../middlewares/authMiddleware.js";
import { reportSchema } from "../validators/validate.js";

const router = express.Router();
const prisma = new PrismaClient();

// 📝 Submit Service Report
router.post("/", authMiddleware, async (req, res) => {
  if (req.user.role !== "TECHNICIAN") {
    return res.status(403).json({ success: false, message: "Access denied" });
  }

  const validation = reportSchema.safeParse(req.body);
  if (!validation.success) {
    return res.status(400).json({
      success: false,
      message: validation.error.errors[0].message,
    });
  }

  const {
    customerName,
    mobileNumber,
    address,
    dateTime,
    serviceType,
    partsUsed,
    amountReceived,
  } = validation.data;

  try {
    let summary = "";
    let totalMoney = 0;

    for (const item of partsUsed) {
      const part = await prisma.part.findUnique({ where: { id: item.id } });
      if (!part || part.quantity < item.quantity) {
        return res.status(400).json({
          success: false,
          message: `Insufficient stock for part: ${item.id}`,
        });
      }

      summary += `${part.name} x${item.quantity}, `;
      totalMoney += part.unitCost * item.quantity;

      await prisma.part.update({
        where: { id: item.id },
        data: { quantity: { decrement: item.quantity } },
      });
    }

    summary = summary.replace(/, $/, "");

    const report = await prisma.report.create({
      data: {
        technicianId: req.user.id,
        customerName,
        mobileNumber,
        address,
        dateTime: new Date(dateTime),
        serviceType,
        amountReceived,
        summary,
        totalMoney,
      },
    });

    res.status(201).json({
      success: true,
      message: "Report submitted successfully",
      report,
    });
  } catch (error) {
    console.error("Error submitting report:", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

// 📄 Get All Reports
router.get("/", authMiddleware, async (req, res) => {
  try {
    const reports = await prisma.report.findMany({
      include: {
        technician: {
          select: {
            id: true,
            name: true,
            phone: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    res.json({ success: true, reports });
  } catch (error) {
    console.error("Error fetching reports:", error.stack || error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

// 🔄 Update Report by ID
router.put("/:reportId", authMiddleware, async (req, res) => {
  const { reportId } = req.params;

  if (req.user.role !== "TECHNICIAN") {
    return res.status(403).json({ success: false, message: "Access denied" });
  }

  const validation = reportSchema.safeParse(req.body);
  if (!validation.success) {
    return res.status(400).json({
      success: false,
      message: validation.error.errors[0].message,
    });
  }

  const {
    customerName,
    mobileNumber,
    address,
    dateTime,
    serviceType,
    partsUsed,
    amountReceived,
  } = validation.data;

  try {
    const existingReport = await prisma.report.findUnique({
      where: { id: reportId },
    });

    if (!existingReport) {
      return res.status(404).json({ success: false, message: "Report not found" });
    }

    if (existingReport.technicianId !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: "You can only update your own reports",
      });
    }

    // Revert stock from old parts
    const previousSummaryParts = (existingReport.summary || "")
      .split(", ")
      .map((entry) => {
        const parts = entry.split(" x");
        if (parts.length !== 2) return null;
        return {
          name: parts[0].trim(),
          quantity: parseInt(parts[1].trim()) || 0,
        };
      })
      .filter(Boolean);

    for (const prev of previousSummaryParts) {
      const part = await prisma.part.findFirst({ where: { name: prev.name } });
      if (part) {
        await prisma.part.update({
          where: { id: part.id },
          data: { quantity: { increment: prev.quantity } },
        });
      }
    }

    // Apply new parts
    let newSummary = "";
    let newTotalMoney = 0;

    for (const item of partsUsed) {
      const part = await prisma.part.findUnique({ where: { id: item.id } });
      if (!part || part.quantity < item.quantity) {
        return res.status(400).json({
          success: false,
          message: `Insufficient stock for part: ${item.id}`,
        });
      }

      newSummary += `${part.name} x${item.quantity}, `;
      newTotalMoney += part.unitCost * item.quantity;

      await prisma.part.update({
        where: { id: item.id },
        data: { quantity: { decrement: item.quantity } },
      });
    }

    newSummary = newSummary.replace(/, $/, "");

    const updatedReport = await prisma.report.update({
      where: { id: reportId },
      data: {
        customerName,
        mobileNumber,
        address,
        dateTime: new Date(dateTime),
        serviceType,
        amountReceived,
        summary: newSummary,
        totalMoney: newTotalMoney,
      },
    });

    res.json({
      success: true,
      message: "Report updated successfully",
      report: updatedReport,
    });
  } catch (error) {
    console.error("Error updating report:", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

export default router;
